# Локализация точек автомобильных номеров

## Итоговое решение

Финальным решением стала модель на базе энкодера ResNet-18 с 8 выходами для каждой координаты ключевых точек (см. рисунок `model_arch.png`).

1) Клонирование репозитория

    ```(bash)
    git clone https://github.com/t0sssik/license_plate_points.git
    cd license_plate_points
    ```

2) Установка зависимостей

    ```(bash)
    pip install -r requirements.txt
    ```

3) Запуск скрипта

    ```(bash)
    python resnet_onnx_run.py \
            --model models/lpl_resnet.onnx \
            --input_path <input_image> \
            --output_path <output_image>
    ```

В таблице ниже представлены основные рабочие модели. Подробнее про вычисление времени и качества можно посмотреть в файле `torch_training.ipynb`.

| Модель | Описание | Время работы (мс) | Метрика (MAE) | Размер модели (МБ) |
|--------|----------|-------------------|---------------|---------------|
| `lpl_resnet.onnx` | Обученная модель без квантизации | 29.71 | 0.003695 | 43.1 |
| `lpl_resnet_static_quantized.onnx` | Модель после статической квантизации | 15.50 | 0.004833 | 10.8 |
| `lpl_resnet_dynamic_quantized.onnx` |Модель после динамичесой квантизации | 46.14 | 0.004124 | 10.8 |

## Рефлексия по выполнению тестового задания

В ходе выполнения тестового задания были рассмотрены 2 подхода:

- использование модели YOLO Pose;
- разработка собственной архитектуры.

В первую очередь, я проанализировал данные (`data_analysis.ipynb`). Посмотрел, что представляют из себя данные, какие размеры, какой баланс между однострочными и двустрочными номерами.

Начал я с первого подхода - YOLO, так как это первое, что приходит в голову при решении задачи локализации ключевых точек (`yolo_training.ipynb`). Для использования модели необходимо было подготовить данные, в чатсности разметку. Все файлы в папке `utils` использовались для этого. В качестве модели я выбрал 11 версию nano.

В ходе обучения возникло много трудностей, в первую очередь связанных с трекингом процесса обучения. Из-за ограниченного интерфейса библиотеки ultralitics сделать это тяжелее, чем в ручном режиме. Также, возникли вопросы с динамическими размерами. А формат выхода у YOLO Pose максимально запутанный.

На данный подход было потрачено много времени, но добиться получилось только удовлетворительного результата. Оставил все подготовительные файлы, файл с процессом обучения и скрипт для запуска для наглядности

Второй подход оказался для меня ближе и проще, так как у меня много опыта работы с энкодер-декодер архитектурами (`torch_training.ipynb`). В качестве энкодера я взял простенький ResNet-18, а декодер реализовал в виде 2 линейных слоев с 8 выходами (координатами 4 точек). Для датасета я взял предобработанные ранее для YOLO лейблы, но пришлось руками реализовать letterbox для подгонки размера. Координаты также пришлось пересчитывать. В качесте функции потерь выбрал MAE. Для трекинга я использовал Tensorboard. В результате получилась модель, которая и стала финальной в данном проекте.

Дополнительно провел эксперименты с квантизацией, сравнил динамическую и статическую.

Таким образом, за неделю удалось рассмотреть и реализовать два подхода. Задание мне показалось простым, но интересным, так как смог поработать с архитектурами, которые ранее в рабочих проектах не использовал.
